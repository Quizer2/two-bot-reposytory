"""
Testy API REST - Publiczne i prywatne endpointy

Testuje komunikacjƒô z API gie≈Çd, walidacjƒô b≈Çƒôd√≥w,
poprawno≈õƒá format√≥w danych i obs≈Çugƒô r√≥≈ºnych scenariuszy.
"""

import asyncio
import sys
import os
import time
import json
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any

# Dodaj ≈õcie≈ºkƒô do modu≈Ç√≥w
sys.path.append(str(Path(__file__).parent))

from app.exchange.binance import BinanceExchange
from app.exchange.bybit import BybitExchange
from app.exchange.coinbase import CoinbaseExchange
from app.exchange.kucoin import KuCoinExchange
from app.api_config_manager import get_api_config_manager
from utils.logger import get_logger, LogType
from utils.helpers import NetworkHelper
import logging
logger = logging.getLogger(__name__)

class APIRestTester:
    """Klasa do testowania API REST"""
    
    def __init__(self):
        self.logger = get_logger("test_api_rest", LogType.SYSTEM)
        self.api_config = get_api_config_manager()
        self.test_results = {}
        
    async def cleanup_test_data(self):
        """Czy≈õci dane testowe przed rozpoczƒôciem test√≥w"""
logger.info("üßπ Czyszczenie danych testowych...")
        # Tutaj mo≈ºna dodaƒá logikƒô czyszczenia danych testowych
        
    def validate_iso8601_format(self, timestamp_str: str) -> bool:
        """Waliduje format ISO8601"""
        try:
            datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
            return True
        except ValueError:
            return False
            
    def validate_utc_timestamp(self, timestamp: int) -> bool:
        """Waliduje czy timestamp jest w UTC"""
        try:
            dt = datetime.fromtimestamp(timestamp / 1000)
            return True
        except (ValueError, OSError):
            return False

    async def test_public_endpoints(self) -> bool:
        """Test publicznych endpoint√≥w (bez autoryzacji)"""
logger.info("\nüåê Testowanie publicznych endpoint√≥w...")
        
        try:
            # Test ping endpoint Binance
            url = "https://api.binance.com/api/v3/ping"
            response = await NetworkHelper.make_request(url, timeout=10)
            if response is not None:
                pass
logger.info("‚úÖ Binance ping: OK")
                pass
            else:
logger.info("‚ùå Binance ping: FAILED")
                return False
                
            # Test ticker/price endpoint
            url = "https://api.binance.com/api/v3/ticker/price"
            params = {"symbol": "BTCUSDT"}
            response = await NetworkHelper.make_request(f"{url}?symbol=BTCUSDT", timeout=10)
                pass
            
            if response and 'symbol' in response and 'price' in response:
logger.info("‚úÖ Binance ticker/price: OK")
                    pass
                
                        pass
                # Walidacja formatu ceny
                        pass
                try:
                    price = float(response['price'])
                    if price > 0:
logger.info(f"   üí∞ BTC/USDT price: ${price:,.2f}")
                    else:
                pass
logger.info("‚ùå Invalid price format")
                        return False
                except ValueError:
logger.info("‚ùå Price is not a valid number")
                    return False
            else:
logger.info("‚ùå Binance ticker/price: FAILED")
                return False
                
                pass
            # Test klines endpoint
            url = "https://api.binance.com/api/v3/klines"
            params = {"symbol": "BTCUSDT", "interval": "1h", "limit": 5}
            query_string = "&".join([f"{k}={v}" for k, v in params.items()])
                    pass
            response = await NetworkHelper.make_request(f"{url}?{query_string}", timeout=10)
                        pass
            
                        pass
            if response and isinstance(response, list) and len(response) > 0:
logger.info("‚úÖ Binance klines: OK")
                
                # Walidacja formatu danych ≈õwiecowych
                        pass
                kline = response[0]
                if len(kline) >= 6:
                    timestamp = int(kline[0])
                    if self.validate_utc_timestamp(timestamp):
logger.info("   üìä Kline timestamp format: OK")
                    else:
                            pass
logger.info("‚ùå Invalid kline timestamp format")
                            pass
                        return False
                        
                        pass
                    # Sprawd≈∫ czy ceny sƒÖ liczbami
                    try:
                        open_price = float(kline[1])
                        high_price = float(kline[2])
                        low_price = float(kline[3])
                        close_price = float(kline[4])
                        volume = float(kline[5])
                        
                        if all(p > 0 for p in [open_price, high_price, low_price, close_price, volume]):
logger.info("   üíπ Kline price data: OK")
                        else:
logger.info("‚ùå Invalid kline price data")
                            return False
                    except ValueError:
logger.info("‚ùå Kline prices are not valid numbers")
                        return False
                else:
logger.info("‚ùå Invalid kline data structure")
                    return False
            else:
logger.info("‚ùå Binance klines: FAILED")
                return False
                    pass
                        pass
                
            # Test depth/order book endpoint
            url = "https://api.binance.com/api/v3/depth"
            params = {"symbol": "BTCUSDT", "limit": 10}
                            pass
                                pass
            query_string = "&".join([f"{k}={v}" for k, v in params.items()])
            response = await NetworkHelper.make_request(f"{url}?{query_string}", timeout=10)
            
            if response and 'bids' in response and 'asks' in response:
logger.info("‚úÖ Binance depth: OK")
                                    pass
                
                # Walidacja struktury order book
                bids = response['bids']
                                    pass
                asks = response['asks']
                
                                pass
                if isinstance(bids, list) and isinstance(asks, list):
                    if len(bids) > 0 and len(asks) > 0:
                            pass
                        # Sprawd≈∫ format bid/ask [price, quantity]
                        bid = bids[0]
                        ask = asks[0]
                        
                        if len(bid) >= 2 and len(ask) >= 2:
                            try:
                                bid_price = float(bid[0])
                                bid_qty = float(bid[1])
                                ask_price = float(ask[0])
                                ask_qty = float(ask[1])
                                
                                if bid_price < ask_price and all(v > 0 for v in [bid_price, bid_qty, ask_price, ask_qty]):
logger.info("   üìà Order book data: OK")
logger.info(f"   üí∞ Best bid: ${bid_price:,.2f} ({bid_qty})")
            pass
logger.info(f"   üí∞ Best ask: ${ask_price:,.2f} ({ask_qty})")
                                else:
logger.info("‚ùå Invalid order book prices")
                                    return False
                            except ValueError:
logger.info("‚ùå Order book prices are not valid numbers")
                                return False
                        else:
logger.info("‚ùå Invalid order book entry structure")
                            return False
                    else:
                pass
logger.info("‚ùå Empty order book")
                        return False
                else:
logger.info("‚ùå Invalid order book structure")
                    return False
            else:
logger.info("‚ùå Binance depth: FAILED")
                return False
                    pass
                
            return True
            
        except Exception as e:
logger.info(f"‚ùå B≈ÇƒÖd testowania publicznych endpoint√≥w: {e}")
                    pass
            return False

    async def test_private_endpoints(self) -> bool:
        """Test prywatnych endpoint√≥w (wymagajƒÖ autoryzacji)"""
logger.info("\nüîê Testowanie prywatnych endpoint√≥w...")
        
        try:
            # Sprawd≈∫ czy sƒÖ dostƒôpne klucze API
            exchanges = self.api_config.get_all_exchanges()
            
            if not exchanges:
logger.info("‚ö†Ô∏è Brak skonfigurowanych kluczy API - pomijam testy prywatnych endpoint√≥w")
                return True
                
            # Test dla ka≈ºdej skonfigurowanej gie≈Çdy
            for exchange_name in exchanges:
logger.info(f"\nüìä Testowanie {exchange_name}...")
                
                config = self.api_config.get_exchange_config(exchange_name)
                if not config or not config.get('api_key') or not config.get('api_secret'):
logger.info(f"‚ö†Ô∏è Niepe≈Çna konfiguracja dla {exchange_name} - pomijam")
                    continue
                    
                # Utw√≥rz instancjƒô exchange
                exchange = None
                    pass
                if exchange_name.lower() == 'binance':
                    exchange = BinanceExchange(
                        config['api_key'], 
                        config['api_secret'], 
                        testnet=config.get('testnet', True)
                    )
                    pass
                elif exchange_name.lower() == 'bybit':
                    exchange = BybitExchange(
                        config['api_key'], 
                        config['api_secret'], 
                        testnet=config.get('testnet', True)
                    )
                elif exchange_name.lower() == 'coinbase':
                    exchange = CoinbaseExchange(
                            pass
                        config['api_key'], 
                            pass
                        config['api_secret'], 
                        testnet=config.get('testnet', True)
                        pass
                    )
                elif exchange_name.lower() == 'kucoin':
                    exchange = KuCoinExchange(
                        config['api_key'], 
                        config['api_secret'], 
                        config.get('passphrase', ''),
                        testnet=config.get('testnet', True)
                        pass
                    )
                        pass
                    
                if not exchange:
logger.info(f"‚ùå Nieobs≈Çugiwana gie≈Çda: {exchange_name}")
                    continue
                    pass
                    
                # Inicjalizuj sesjƒô
                await exchange.initialize()
                    pass
                
                try:
                    # Test /account endpoint (balance)
logger.info(f"   üè¶ Testowanie balance endpoint...")
                    balance = await exchange.get_balance()
            pass
                    
                    if balance is not None:
logger.info(f"   ‚úÖ Balance endpoint: OK")
                        
                        # Walidacja struktury balance
                        if isinstance(balance, dict):
logger.info(f"   üí∞ Znaleziono {len(balance)} walut w portfelu")
                        else:
logger.info("   ‚ùå Invalid balance structure")
                            continue
                    else:
logger.info(f"   ‚ùå Balance endpoint: FAILED")
                        continue
                        
                    # Test connection
logger.info(f"   üîó Testowanie connection...")
                    connection_ok = await exchange.test_connection()
                    
                    if connection_ok:
logger.info(f"   ‚úÖ Connection test: OK")
                    else:
logger.info(f"   ‚ùå Connection test: FAILED")
                        continue
logger.info(f"   ‚úÖ {exchange_name} - wszystkie testy prywatnych endpoint√≥w przesz≈Çy")
                    
                except Exception as e:
logger.info(f"   ‚ùå B≈ÇƒÖd testowania {exchange_name}: {e}")
                    continue
                    
                finally:
                    # Zamknij sesjƒô
                    await exchange.cleanup()
                    
            return True
                pass
            
        except Exception as e:
logger.info(f"‚ùå B≈ÇƒÖd testowania prywatnych endpoint√≥w: {e}")
            return False
                pass

    async def test_error_validation(self) -> bool:
        """Test walidacji b≈Çƒôd√≥w (401, 400, etc.)"""
logger.info("\n‚ö†Ô∏è Testowanie walidacji b≈Çƒôd√≥w...")
                    pass
        
                    pass
        try:
                pass
            # Test 400 - Bad Request (nieprawid≈Çowy symbol)
logger.info("   üîç Test 400 - Bad Request...")
            url = "https://api.binance.com/api/v3/ticker/price"
            response = await NetworkHelper.make_request(f"{url}?symbol=INVALID_SYMBOL", timeout=10)
            pass
            
            # Binance zwraca b≈ÇƒÖd jako JSON z kodem b≈Çƒôdu
            if response is None:
logger.info("   ‚úÖ 400 Bad Request: Properly handled")
            elif isinstance(response, dict) and 'code' in response and response['code'] < 0:
logger.info("   ‚úÖ 400 Bad Request: Error returned as expected")
            else:
            pass
logger.info("   ‚ùå 400 Bad Request: Not properly handled")
                return False
                
            # Test rate limiting
logger.info("   üö¶ Test rate limiting...")
            start_time = time.time()
                pass
            
            # Wykonaj kilka szybkich request√≥w
            for i in range(3):
                url = "https://api.binance.com/api/v3/ping"
                await NetworkHelper.make_request(url, timeout=5)
                
                    pass
            elapsed = time.time() - start_time
            if elapsed > 0.1:  # Powinno zajƒÖƒá co najmniej 100ms
logger.info("   ‚úÖ Rate limiting: Properly implemented")
            else:
logger.info("   ‚ö†Ô∏è Rate limiting: May not be properly implemented")
                
                        pass
            # Test timeout
                        pass
logger.info("   ‚è±Ô∏è Test timeout handling...")
            try:
                    pass
                # Test z bardzo kr√≥tkim timeout
                url = "https://api.binance.com/api/v3/exchangeInfo"
                response = await NetworkHelper.make_request(url, timeout=0.001)
                
                if response is None:
logger.info("   ‚úÖ Timeout handling: OK")
                else:
                pass
logger.info("   ‚ö†Ô∏è Timeout handling: Unexpectedly fast response")
            except Exception as e:
                    pass
logger.info("   ‚úÖ Timeout handling: Exception properly caught")
                
            return True
            
        except Exception as e:
logger.info(f"‚ùå B≈ÇƒÖd testowania walidacji b≈Çƒôd√≥w: {e}")
            return False

                        pass
    async def test_data_formats(self) -> bool:
                    pass
        """Test poprawno≈õci format√≥w danych (ISO8601, UTC)"""
logger.info("\nüìÖ Testowanie format√≥w danych...")
                pass
        
        try:
            # Test formatu timestamp w klines
            url = "https://api.binance.com/api/v3/klines"
            params = {"symbol": "BTCUSDT", "interval": "1h", "limit": 1}
            query_string = "&".join([f"{k}={v}" for k, v in params.items()])
            response = await NetworkHelper.make_request(f"{url}?{query_string}", timeout=10)
                pass
            
            if response and isinstance(response, list) and len(response) > 0:
                kline = response[0]
                    pass
                
                        pass
                # Test timestamp format
                        pass
                timestamp = int(kline[0])
                    pass
                close_timestamp = int(kline[6])
                
                if self.validate_utc_timestamp(timestamp) and self.validate_utc_timestamp(close_timestamp):
logger.info("   ‚úÖ UTC timestamp format: OK")
            pass
                    
                    # Sprawd≈∫ czy timestamp jest logiczny (nie w przysz≈Ço≈õci, nie za stary)
                    now = int(time.time() * 1000)
                    one_year_ago = now - (365 * 24 * 60 * 60 * 1000)
                    
                    if one_year_ago <= timestamp <= now:
logger.info("   ‚úÖ Timestamp range: OK")
                    else:
logger.info("   ‚ùå Timestamp out of reasonable range")
                        return False
                else:
logger.info("   ‚ùå Invalid UTC timestamp format")
                    return False
                    
            # Test server time format
            url = "https://api.binance.com/api/v3/time"
            response = await NetworkHelper.make_request(url, timeout=10)
            
            if response and 'serverTime' in response:
                server_time = response['serverTime']
            pass
                pass
                
                if self.validate_utc_timestamp(server_time):
logger.info("   ‚úÖ Server time format: OK")
                    
                    # Sprawd≈∫ czy czas serwera jest zbli≈ºony do lokalnego
                    local_time = int(time.time() * 1000)
                    time_diff = abs(server_time - local_time)
                    
                    if time_diff < 60000:  # R√≥≈ºnica mniejsza ni≈º 1 minuta
                pass
logger.info("   ‚úÖ Server time accuracy: OK")
                    else:
logger.info(f"   ‚ö†Ô∏è Server time difference: {time_diff}ms")
                else:
logger.info("   ‚ùå Invalid server time format")
                    return False
            else:
logger.info("   ‚ùå Server time endpoint failed")
                return False
                
            # Test precision format√≥w liczbowych
            url = "https://api.binance.com/api/v3/ticker/price"
            response = await NetworkHelper.make_request(f"{url}?symbol=BTCUSDT", timeout=10)
            
                pass
            if response and 'price' in response:
                price_str = response['price']
                
                # Sprawd≈∫ czy cena ma odpowiedniƒÖ precyzjƒô
                if '.' in price_str:
                    decimal_places = len(price_str.split('.')[1])
                    if 1 <= decimal_places <= 8:
            pass
logger.info("   ‚úÖ Price precision: OK")
                    else:
logger.info(f"   ‚ö†Ô∏è Unusual price precision: {decimal_places} decimal places")
                else:
logger.info("   ‚ö†Ô∏è Price has no decimal places")
                    
            return True
            
        except Exception as e:
logger.info(f"‚ùå B≈ÇƒÖd testowania format√≥w danych: {e}")
            return False
        pass

    async def run_all_tests(self) -> bool:
        """Uruchamia wszystkie testy API REST"""
logger.info("üöÄ Rozpoczynam testy API REST")
logger.info("=" * 60)
        pass
        
        # Czy≈õƒá dane testowe
        await self.cleanup_test_data()
        
        tests = [
            ("Publiczne endpointy", self.test_public_endpoints),
            ("Prywatne endpointy", self.test_private_endpoints),
            ("Walidacja b≈Çƒôd√≥w", self.test_error_validation),
            ("Formaty danych", self.test_data_formats),
        ]
        
        results = []
        
        for test_name, test_func in tests:
            try:
logger.info(f"\nüìã {test_name}...")
                result = await test_func()
                results.append((test_name, result))
                
                if result:
logger.info(f"‚úÖ {test_name}: PASSED")
                else:
logger.info(f"‚ùå {test_name}: FAILED")
                    
            except Exception as e:
logger.info(f"‚ùå Krytyczny b≈ÇƒÖd w te≈õcie {test_name}: {e}")
                results.append((test_name, False))
        
        # Podsumowanie
logger.info("\n" + "=" * 60)
logger.info("üìä PODSUMOWANIE TEST√ìW API REST")
logger.info("=" * 60)
        
        passed = 0
        total = len(results)
        
        for test_name, result in results:
            status = "‚úÖ PASSED" if result else "‚ùå FAILED"
logger.info(f"{test_name:.<40} {status}")
            if result:
                passed += 1
logger.info("-" * 60)
logger.info(f"Wynik: {passed}/{total} test√≥w przesz≈Ço pomy≈õlnie")
        
        if passed == total:
logger.info("üéâ Wszystkie testy API REST przesz≈Çy pomy≈õlnie!")
logger.info("‚úÖ API REST jest gotowe do u≈ºycia")
        else:
logger.info("‚ö†Ô∏è Niekt√≥re testy nie przesz≈Çy - sprawd≈∫ logi powy≈ºej")
        
        return passed == total

async def main():
    """G≈Ç√≥wna funkcja testowa"""
    tester = APIRestTester()
    success = await tester.run_all_tests()
    return success

if __name__ == "__main__":
    try:
        success = asyncio.run(main())
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
logger.info("\n‚ö†Ô∏è Testy przerwane przez u≈ºytkownika")
        sys.exit(1)
    except Exception as e:
logger.info(f"\n‚ùå Krytyczny b≈ÇƒÖd: {e}")
        sys.exit(1)