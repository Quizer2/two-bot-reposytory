A. Priorytety (kolejność prac — najpierw to zrób) 

Dodać EventBus / subskrypcje w utils/config_manager.py (tak, żeby UI → Config → powiadomienia działały). 

W RiskManager: zaimplementować load_limits_from_db(bot_id), reload_limits(bot_id) i reload_all_limits() oraz korzystać z DB zamiast zawsze zwracać defaulty. 

Ujednolicić użycie DataManagera: wstrzykiwać jedną instancję (get_data_manager() or get_integrated_data_manager()), zrefactorować importy (core vs app). 

Przy tworzeniu strategii w BotManager (i updated_bot_manager) przekazywać jawnie risk_manager, data_manager, db_manager, notification_manager. 

Dodać logi trace do flow: config.updated, risk.reloaded, order.submitted (łatwiejsze debugowanie). 

Dodać test E2E: „zmiana limitu w UI → bot reaguje”. 

 
 

B. Pliki i gotowe patche / implementacje 

Uwaga: wklej poniższe bloki do wymienionych plików (upewnij się, że zachowany jest styl projektu). Jeśli projekt używa Git — zrób branch fix/config-events-risk i zacommituj zmiany. 

 
 

1) utils/event_bus.py — prosty pub/sub (nowy plik) 

Ścieżka: New bot/utils/event_bus.py 

# utils/event_bus.py import threading import logging from typing import Callable, Dict, List, Any logger = logging.getLogger("EventBus") class EventBus: """Prosty, synchroniczny Event Bus (pub/sub).""" def __init__(self): self._listeners: Dict[str, List[Callable[..., Any]]] = {} self._lock = threading.RLock() def subscribe(self, event_name: str, callback: Callable[..., Any]) -> None: with self._lock: self._listeners.setdefault(event_name, []).append(callback) logger.debug("Subscribed callback to event %s", event_name) def unsubscribe(self, event_name: str, callback: Callable[..., Any]) -> None: with self._lock: if event_name in self._listeners and callback in self._listeners[event_name]: self._listeners[event_name].remove(callback) def publish(self, event_name: str, *args, **kwargs) -> None: with self._lock: callbacks = list(self._listeners.get(event_name, [])) for cb in callbacks: try: cb(*args, **kwargs) except Exception: logger.exception("Event callback error for %s", event_name) # Singleton instance convenience _event_bus = None def get_event_bus() -> EventBus: global _event_bus if _event_bus is None: _event_bus = EventBus() return _event_bus  

 
 

2) utils/config_manager.py — rozszerzenie o listenery / notify 

Ścieżka: New bot/utils/config_manager.py 

Zastąp lub rozszerz istniejącą klasę ConfigManager o fragmenty poniżej. (Wklej funkcje __init__, register_listener, _notify, i dolny fragment wywołujący _notify w set_setting i/lub save_config.) 

# (w ConfigManager.__init__) self._listeners = {} # namespace -> list(callback) def register_listener(self, namespace: str, callback): """ Zarejestruj listener, np. namespace='risk' lub 'bot' callback signature: callback(path: str, value: Any, meta: dict) """ self._listeners.setdefault(namespace, []).append(callback) def unregister_listener(self, namespace: str, callback): if namespace in self._listeners and callback in self._listeners[namespace]: self._listeners[namespace].remove(callback) def _notify_listeners(self, namespace: str, path: str, value, meta: dict = None): meta = meta or {} callbacks = list(self._listeners.get(namespace, [])) for cb in callbacks: try: cb(path, value, meta) except Exception: # Nie powinno crashować aplikacji logger = get_logger("ConfigManager") logger.exception("Notify listener error for %s", namespace)  

W metodzie set_setting(...) po self.save_config(...) dodaj: 

# determine namespace ns = "risk" if "risk" in path or path.startswith("risk_") else "app" # send metadata optionally: who changed, timestamp, bot_id if present meta = {"by": "ui", "ts": datetime.now(timezone.utc).isoformat()} self._notify_listeners(ns, path, value, meta) # also publish on EventBus for global subscribers from utils.event_bus import get_event_bus get_event_bus().publish(f"config.{ns}.updated", path=path, value=value, meta=meta)  

Dlaczego: powiadomienie (listener + EventBus) pozwala RiskManagerowi i BotManagerowi natychmiast odświeżyć cache bez potrzeby pollowania plików. 

 
 

3) app/risk_management.py — metody ładowania limitów z DB i reload 

Ścieżka: New bot/app/risk_management.py 

Dodaj / zmodyfikuj metody (wstaw w klasie RiskManager): 

def load_limits_from_db(self, bot_id: int): """Wczytaj limity ryzyka dla danego bota z bazy (jeśli istnieją).""" try: if not self.db_manager: return self.default_limits row = self.db_manager.fetchone( "SELECT max_daily_loss_percent, max_daily_profit_percent, max_drawdown_percent, " "max_position_size_percent, stop_loss_percent, take_profit_percent " "FROM risk_settings WHERE bot_id = ?", (bot_id,) ) if not row: return self.default_limits # Mapowanie z bazy do obiektu RiskLimits (dostosuj nazwy pól jeśli trzeba) rl = RiskLimits( daily_loss_limit = float(row.get('max_daily_loss_percent') or self.default_limits.daily_loss_limit), daily_profit_limit = float(row.get('max_daily_profit_percent') or self.default_limits.daily_profit_limit), max_drawdown_limit = float(row.get('max_drawdown_percent') or self.default_limits.max_drawdown_limit), position_size_limit = float(row.get('max_position_size_percent') or self.default_limits.position_size_limit), stop_loss_limit = float(row.get('stop_loss_percent') or self.default_limits.stop_loss_limit), take_profit_limit = float(row.get('take_profit_percent') or self.default_limits.take_profit_limit), max_open_positions = int(row.get('max_open_positions') or self.default_limits.max_open_positions), max_correlation = float(row.get('max_correlation') or self.default_limits.max_correlation) ) return rl except Exception: self.logger.exception("Failed to load limits from DB, returning defaults") return self.default_limits def reload_limits(self, bot_id: int): """Wymusz odczyt limitów z DB i zapisz w cache.""" with self._lock: self.limits_cache[bot_id] = self.load_limits_from_db(bot_id) self.logger.info("Reloaded risk limits for bot %s", bot_id) def reload_all_limits(self): """Reload limits for all known bots (used after global changes).""" with self._lock: bot_ids = self.db_manager.fetch_column("SELECT id FROM bots") if self.db_manager else [] for b in bot_ids: try: self.limits_cache[b] = self.load_limits_from_db(b) except Exception: self.logger.exception("Failed reloading limits for bot %s", b) self.logger.info("Reloaded limits for all bots")  

Dodatkowo: w __init__ RiskManager dodaj subskrypcję na EventBus lub ConfigManager listeners (patrz przykład poniżej). 

Rejestracja listenera przykład (w RiskManager.init): 

from utils.event_bus import get_event_bus eb = get_event_bus() eb.subscribe("config.risk.updated", lambda path, value, meta=None: self.reload_all_limits()) # albo rejestracja per-bot (parset path do bot_id jeśli path zawiera bot id)  

 
 

4) app/bot_manager.py — przekazywanie instancji do strategii 

Ścieżka: New bot/app/bot_manager.py (lub core/updated_bot_manager.py jeśli używacie tego) 

Znajdź miejsce, gdzie instancje strategii są tworzone — upewnij się, że konstruktory otrzymują risk_manager i data_manager. Przykład: 

from app.risk_management import get_risk_manager from core.integrated_data_manager import get_integrated_data_manager rm = get_risk_manager(db_manager=self.db) dm = get_integrated_data_manager() strategy = GridStrategy(bot_id=bot_id, config=bot_config, data_manager=dm, risk_manager=rm, db_manager=self.db, notification_manager=self.notification_manager) self.active_strategies[bot_id] = strategy  

Jeśli w projekcie są alternatywne GridStrategy implementacje, ujednolić podpis konstruktora. 

 
 

5) app/trading_mode_manager.py — upewnić dispatch do TradingEngine 

Ścieżka: New bot/app/trading_mode_manager.py (sprawdź, żeby wywoływał TradingEngine.submit_order() a nie bezpośrednie API z wielu miejsc) 

W miejscu gdzie tworzone są zlecenia, zrób: 

from app.trading_engine import get_trading_engine engine = get_trading_engine(mode=self.current_mode) # engine zwraca PaperEngine lub LiveEngine result = engine.submit_order(order_request) # zapisz result do DB i publish event get_event_bus().publish("order.submitted", order=order_request, result=result)  

I upewnij się, że PaperEngine i LiveEngine implementują ten sam interface (submit_order, cancel_order, get_order_status). 

 
 

C. Instrukcja wdrożenia krok-po-kroku (dla developera) 

Stwórz branch: 

git checkout -b fix/config-events-risk  

Dodaj plik utils/event_bus.py i wklej kod z sekcji (2). 

Edytuj utils/config_manager.py: dodaj pola _listeners, metody register_listener, _notify_listeners, i zrób get_event_bus().publish(...) po save_config. 

Edytuj app/risk_management.py według kodu z sekcji (3): load_limits_from_db, reload_limits, reload_all_limits. Zarejestruj subskrypcję na config.risk.updated w __init__. 

Edytuj tworzenie strategii w app/bot_manager.py (lub core/updated_bot_manager.py) — przekazuj risk_manager, data_manager, db_manager. 

Upewnij się, że TradingEngine ma interfejs i TradingModeManager korzysta z niego. 

Uruchom linter i testy (jeśli są): 

# opcjonalnie środowisko venv python -m venv .venv source .venv/bin/activate pip install -r requirements.txt # uruchom testy (jeśli pytest) pytest -q  

Commituj i otwórz PR: 

git add . git commit -m "Add eventbus and config listeners; load risk limits from DB; inject managers into strategies" git push origin fix/config-events-risk # otwórz PR i dołącz tę checklistę  

 
 

D. Jak ręcznie zweryfikować poprawność (operační testy) 

(Wszystkie poniższe kroki można wykonać lokalnie; zakładam, że DB to SQLite z plikiem data.db w projekcie.) 

1) Test powiadomień config → RiskManager 

W terminalu (albo w logach) obserwuj logger RiskManager i ConfigManager. 

Zmien w UI wartość stop_loss dla bota z 5 → 3. 

Oczekiwane: 

log ConfigManager zapisuje config i publikuje config.risk.updated. 

RiskManager loguje Reloaded risk limits for bot X. 

limits_cache[bot_id] odzwierciedla nową wartość. 

SQL: sprawdź wpisy w risk_settings: 

sqlite3 data.db "SELECT * FROM risk_settings WHERE bot_id=42;"  

2) Test E2E: UI → Bot behavior 

Ustaw max_position_size na małą wartość (np. 10 USD). 

Uruchom bota w trybie paper. 

Wygeneruj sygnał kupna na większą kwotę (symulacja). 

Oczekiwane: RiskManager odrzuca order (z logiem), test potwierdza brak wpisu w orders albo status rejected. 

Logi: RiskManager: Order rejected due to position_size_limit. 

3) Test trybu Paper vs Live 

Przełącz TradingMode na PAPER. 

Uruchom bota i sprawdź, że LiveExchange nie otrzymuje requestów (można sprawdzić to w mockach lub w logach na ExchangeConnector). 

Sprawdź, że orders zapisywane są jako simulated i nie mają exchange_order_id. 

4) Test widgetów (spójność) 

Wykonaj operację (np. zlecenie) i upewnij się: 

Data zapisane w DB (orders table), 

DataManager / EventBus publishuje order.filled → Dashboard subskrybuje i odświeża. 

Porównaj wartości: Dashboard saldo == Portfolio widget saldo == wynik zapytania SQL. 

 
 

E. Pełna, doprecyzowana checklista testowa (do przekazania testerowi — krok-po-kroku) 

Skopiuj tę listę do JIRA/Excel. Każdy test ma kolumny: ID, opis, kroki, oczekiwany rezultat, wynik (OK/FAIL), komentarz. 

(Ze względu na długość tu jest skondensowana — pełna lista gotowa do CSV mogę wygenerować na życzenie.) 

A. Config → Risk 

T-001: Edycja risk.stop_loss w UI 

Kroki: edytuj wartość, zapisz 

Oczekiwane: DB risk_settings zaktualizowane; log config.risk.updated; RiskManager reloads; cache zmieniony. 

T-002: Edycja globalnego limitu drawdown 

Kroki: zmień, zapisz, uruchom bot 

Oczekiwane: bot nie otworzy nowych pozycji gdy limit przekroczony. 

B. Bot create/update 

T-010: Utworzenie bota z parametrami 

Kroki: UI -> Nowy Bot -> zapisz 

Oczekiwane: wpis w bots table, bot_config zapisany, można odpalić bota. 

T-011: Update konfiguracji bota działającego 

Kroki: zmień parametry i zaznacz „apply_to_running_bots” 

Oczekiwane: bot w locie pobiera nowe ustawienia i stosuje je. 

C. Order flow & Risk 

T-020: Submit order (over limit) 

Kroki: wymuś order powyżej max_position_size 

Oczekiwane: RiskManager odrzuca → log + status rejected. 

D. TradingMode 

T-030: PAPER mode does not call live exchange 

T-031: LIVE mode does call live exchange and returns exchange_order_id 

E. Data coherence (widgets) 

T-040: Dashboard / Portfolio / Logs show same data after a trade 

T-041: Export CSV matches DB contents 

F. Stability & concurrency 

T-050: 10 bots + 20 markets — monitor mem/cpu, no crashes 

T-051: Burst config updates — no race / corrupt config 

G. Security 

T-060: API keys are stored encrypted (check DB values, should not be plaintext) 

T-061: SQL injection test on config inputs (attempt typical payloads) — app must sanitize/escape 

(Jeśli chcesz, wygeneruję CSV z tymi i dodatkowymi testami szczegółowymi.) 

 
 

F. Dodatkowe materiały, które mogę od razu przygotować (wybierz) 

Przygotować patch file (.diff) z powyższymi zmianami (gotowy do git apply). 

Wygenerować CSV/Excel z pełną rozpisaną checklistą testów (kolumny: ID, opis, kroki, oczekiwany rezultat). 

Napisać skrypt pytest / E2E (Python) który automatycznie przetestuje: config change → risk reload → bot reaction (w trybie paper). 

Wygenerować poprawiony diagram dataflow 2.0 w formacie SVG/PNG (gotowy do przekazania developerowi). 

Powiedz, które z tych chcesz teraz — zrobię to natychmiast i dołączę jako pliki/przykłady gotowe do wklejenia.

 