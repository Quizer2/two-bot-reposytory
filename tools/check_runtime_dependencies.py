#!/usr/bin/env python3
"""Szybki checker zależności runtime wymaganych przed dystrybucją."""
from __future__ import annotations

import argparse
import importlib
import json
import platform
import os
import shutil
import subprocess
from ctypes.util import find_library
from pathlib import Path
from typing import Dict, Tuple

RUNTIME_MODULES = {
    "aiosqlite": "pip install aiosqlite",
    "websockets": "pip install websockets",
    "PyQt6": "pip install PyQt6",
}

SYSTEM_LIBRARIES = {
    "libGL.so.1": "sudo apt-get install -y libgl1",
    "libOpenGL.so.0": "sudo apt-get install -y libopengl0",
}

VENDORED_LIB_DIR = Path("vendor/linux")
BUILDABLE_STUBS = {
    "libGL.so.1": "opengl_stub.c",
    "libOpenGL.so.0": "opengl_stub.c",
}

SOFTWARE_BACKEND_ENV = {
    "QT_OPENGL": "software",
    "QT_QUICK_BACKEND": "software",
    "QT_XCB_FORCE_SOFTWARE_OPENGL": "1",
}

SOFTWARE_BACKEND_ENV_FILE = Path("config/qt_software_backend.env")
RUNTIME_OVERRIDES_FILE = Path("config/runtime_overrides.json")
PRODUCTION_ENV_FILE = Path("config/production.env")
PRODUCTION_ENV_TEMPLATE = Path("config/production.env.example")
DEFAULT_REPORT_PATH = Path("runtime_dependency_report.json")


def check_modules() -> Dict[str, Dict[str, str]]:
    results: Dict[str, Dict[str, str]] = {}
    for module, install_hint in RUNTIME_MODULES.items():
        try:
            importlib.import_module(module)
            results[module] = {"status": "ok"}
        except Exception as exc:  # pragma: no cover - zależy od środowiska
            results[module] = {
                "status": "missing",
                "error": str(exc),
                "install": install_hint,
            }
    return results


def configure_software_backend() -> Dict[str, str]:
    """Persist environment overrides enabling Qt's software renderer."""

    SOFTWARE_BACKEND_ENV_FILE.parent.mkdir(parents=True, exist_ok=True)
    lines = ["# Auto-generated by check_runtime_dependencies.py", "# Source this file before launching the UI if needed."]
    lines.extend(f"export {key}={value}" for key, value in SOFTWARE_BACKEND_ENV.items())
    SOFTWARE_BACKEND_ENV_FILE.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return {
        "status": "configured",
        "path": str(SOFTWARE_BACKEND_ENV_FILE),
        "exports": SOFTWARE_BACKEND_ENV,
    }


def build_stub_library(lib: str) -> Tuple[str | None, Dict[str, str] | None]:
    """Compile a lightweight compatibility stub if possible."""

    if lib not in BUILDABLE_STUBS:
        return None, None

    source = VENDORED_LIB_DIR / BUILDABLE_STUBS[lib]
    target = VENDORED_LIB_DIR / lib

    if target.exists():
        return str(target.resolve()), {"note": "Reusing previously built stub"}

    compiler = shutil.which("gcc")
    if compiler is None:
        return None, {
            "status": "missing",
            "reason": "gcc_not_found",
            "hint": "sudo apt-get install -y build-essential",
        }

    if not source.exists():
        return None, {
            "status": "missing",
            "reason": "source_missing",
            "hint": f"Brak pliku źródłowego stubu: {source}",
        }

    target.parent.mkdir(parents=True, exist_ok=True)
    try:
        subprocess.run(
            [compiler, "-shared", "-fPIC", str(source), "-o", str(target)],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
    except subprocess.CalledProcessError as exc:  # pragma: no cover - zależy od środowiska
        return None, {
            "status": "missing",
            "reason": "build_failed",
            "hint": exc.stderr.decode("utf-8", errors="ignore"),
        }

    if target.exists():
        return str(target.resolve()), {"note": "Stub zbudowany lokalnie"}
    return None, {
        "status": "missing",
        "reason": "unknown",
        "hint": "Nie udało się utworzyć stubu mimo braku błędów kompilacji",
    }


def resolve_vendored_library(lib: str) -> Tuple[str | None, Dict[str, str] | None]:
    """Return path to vendored shared library, building it if needed."""

    candidate = VENDORED_LIB_DIR / lib
    if candidate.exists():
        return str(candidate.resolve()), {"note": "Stub dostępny lokalnie"}

    return build_stub_library(lib)


def ensure_vendored_on_path() -> None:
    """Prepend vendored directory to LD_LIBRARY_PATH for runtime use."""

    if not VENDORED_LIB_DIR.exists():
        return

    current = os.environ.get("LD_LIBRARY_PATH", "")
    entries = [str(VENDORED_LIB_DIR.resolve())]
    if current:
        entries.append(current)
    os.environ["LD_LIBRARY_PATH"] = ":".join(entries)


def check_libraries() -> Tuple[Dict[str, Dict[str, str]], bool]:
    results: Dict[str, Dict[str, str]] = {}
    missing_any = False
    ensure_vendored_on_path()
    for lib, install_hint in SYSTEM_LIBRARIES.items():
        found = find_library(lib.replace(".so", "")) or find_library(lib)
        extra: Dict[str, str] | None = None
        if not found:
            found, extra = resolve_vendored_library(lib)
            if found:
                result_block = {
                    "status": "bundled",
                    "resolved": found,
                }
                if extra:
                    result_block.update(extra)
                results[lib] = result_block
                continue

        if found:
            result_block = {"status": "ok", "resolved": found}
            if extra:
                result_block.update(extra)
            results[lib] = result_block
        else:  # pragma: no cover - zależy od środowiska CI
            result_block = {
                "status": "missing",
                "install": install_hint,
            }
            if extra:
                result_block.update(extra)
            results[lib] = result_block
            missing_any = True
    return results, missing_any


def load_env_file(path: Path) -> Dict[str, str]:
    """Load a simple KEY=VALUE env file."""

    values: Dict[str, str] = {}
    if not path.exists():
        raise FileNotFoundError(f"Brak pliku konfiguracyjnego: {path}")
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        values[key.strip()] = value.strip()
    return values


def sync_sentry_overrides(env_path: Path) -> Dict[str, str]:
    """Persist Sentry DSN/environment metadata into runtime overrides."""

    env_values = load_env_file(env_path)
    sentry_block = {
        "dsn": env_values.get("SENTRY_DSN", ""),
        "environment": env_values.get("SENTRY_ENVIRONMENT", "production"),
        "release": env_values.get("SENTRY_RELEASE", "unknown"),
    }

    existing: Dict[str, object] = {}
    if RUNTIME_OVERRIDES_FILE.exists():
        existing = json.loads(RUNTIME_OVERRIDES_FILE.read_text(encoding="utf-8"))

    existing["sentry"] = sentry_block
    RUNTIME_OVERRIDES_FILE.write_text(
        json.dumps(existing, indent=2, ensure_ascii=False) + "\n", encoding="utf-8"
    )
    return sentry_block


def build_payload() -> Tuple[Dict[str, object], Dict[str, Dict[str, str]], Dict[str, Dict[str, str]]]:
    module_status = check_modules()
    libraries, missing_any = check_libraries()
    software_backend = None
    if missing_any:
        software_backend = configure_software_backend()
    else:
        software_backend = {"status": "not_required"}

    payload = {
        "platform": platform.platform(),
        "python": platform.python_version(),
        "modules": module_status,
        "system_libraries": libraries,
        "software_backend": software_backend,
        "notes": (
            "Uruchom ten skrypt na maszynie docelowej. Jeśli zależności są brakujące,"
            " wykonaj sugerowane komendy instalacyjne przed wydaniem."
        ),
    }

    module_failures = {
        name: meta for name, meta in module_status.items() if meta.get("status") != "ok"
    }
    library_failures = {
        name: meta
        for name, meta in libraries.items()
        if meta.get("status") not in {"ok", "bundled"}
    }

    return payload, module_failures, library_failures


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--sync-sentry",
        action="store_true",
        help="Zapisz konfigurację Sentry z pliku production.env do runtime_overrides.json",
    )
    parser.add_argument(
        "--env-file",
        default=str(PRODUCTION_ENV_FILE if PRODUCTION_ENV_FILE.exists() else PRODUCTION_ENV_TEMPLATE),
        help="Ścieżka do pliku .env zawierającego konfigurację produkcyjną",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Wymuś zgodność z wywołaniami automatyzacji oczekującymi flagi --json (wyjście i tak ma format JSON)",
    )
    parser.add_argument(
        "--write-report",
        action="store_true",
        help=(
            "Zapisz wynik do pliku (domyślnie runtime_dependency_report.json). "
            "Bez tej flagi skrypt wypisuje raport jedynie na stdout."
        ),
    )
    parser.add_argument(
        "--report-path",
        default=str(DEFAULT_REPORT_PATH),
        help=(
            "Ścieżka do zapisu raportu. Używana tylko, jeśli podano --write-report "
            "(lub gdy ścieżka została jawnie zmieniona)."
        ),
    )
    args = parser.parse_args(argv or None)

    payload, module_failures, library_failures = build_payload()

    if args.json:
        # Flaga zachowana dla zgodności z pipeline'ami oczekującymi parametru.
        # Skrypt zawsze zwraca JSON, więc nie musimy podejmować dodatkowych działań.
        pass

    if args.sync_sentry:
        env_path = Path(args.env_file)
        sentry_block = sync_sentry_overrides(env_path)
        payload["sentry"] = {
            "status": "synced",
            "path": str(RUNTIME_OVERRIDES_FILE),
            "values": sentry_block,
        }
    else:
        payload["sentry"] = {"status": "skipped"}

    output = json.dumps(payload, indent=2, ensure_ascii=False)
    print(output)

    should_write = args.write_report or args.report_path != str(DEFAULT_REPORT_PATH)
    if should_write:
        report_path = Path(args.report_path)
        report_path.write_text(output + "\n", encoding="utf-8")

    exit_code = 0 if not (module_failures or library_failures) else 1
    return exit_code


if __name__ == "__main__":
    raise SystemExit(main())
