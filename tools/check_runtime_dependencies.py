#!/usr/bin/env python3
"""Szybki checker zależności runtime wymaganych przed dystrybucją."""
from __future__ import annotations

import argparse
import importlib
import json
import platform
from ctypes.util import find_library
from pathlib import Path
from typing import Dict, Tuple

RUNTIME_MODULES = {
    "aiosqlite": "pip install aiosqlite",
    "websockets": "pip install websockets",
    "PyQt6": "pip install PyQt6",
}

SYSTEM_LIBRARIES = {
    "libGL.so.1": "sudo apt-get install -y libgl1",
    "libOpenGL.so.0": "sudo apt-get install -y libopengl0",
}

SOFTWARE_BACKEND_ENV = {
    "QT_OPENGL": "software",
    "QT_QUICK_BACKEND": "software",
    "QT_XCB_FORCE_SOFTWARE_OPENGL": "1",
}

SOFTWARE_BACKEND_ENV_FILE = Path("config/qt_software_backend.env")
RUNTIME_OVERRIDES_FILE = Path("config/runtime_overrides.json")
PRODUCTION_ENV_FILE = Path("config/production.env")
PRODUCTION_ENV_TEMPLATE = Path("config/production.env.example")


def check_modules() -> Dict[str, Dict[str, str]]:
    results: Dict[str, Dict[str, str]] = {}
    for module, install_hint in RUNTIME_MODULES.items():
        try:
            importlib.import_module(module)
            results[module] = {"status": "ok"}
        except Exception as exc:  # pragma: no cover - zależy od środowiska
            results[module] = {
                "status": "missing",
                "error": str(exc),
                "install": install_hint,
            }
    return results


def configure_software_backend() -> Dict[str, str]:
    """Persist environment overrides enabling Qt's software renderer."""

    SOFTWARE_BACKEND_ENV_FILE.parent.mkdir(parents=True, exist_ok=True)
    lines = ["# Auto-generated by check_runtime_dependencies.py", "# Source this file before launching the UI if needed."]
    lines.extend(f"export {key}={value}" for key, value in SOFTWARE_BACKEND_ENV.items())
    SOFTWARE_BACKEND_ENV_FILE.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return {
        "status": "configured",
        "path": str(SOFTWARE_BACKEND_ENV_FILE),
        "exports": SOFTWARE_BACKEND_ENV,
    }


def check_libraries() -> Tuple[Dict[str, Dict[str, str]], bool]:
    results: Dict[str, Dict[str, str]] = {}
    missing_any = False
    for lib, install_hint in SYSTEM_LIBRARIES.items():
        found = find_library(lib.replace(".so", "")) or find_library(lib)
        if found:
            results[lib] = {"status": "ok", "resolved": found}
        else:  # pragma: no cover - zależy od środowiska CI
            results[lib] = {
                "status": "missing",
                "install": install_hint,
            }
            missing_any = True
    return results, missing_any


def load_env_file(path: Path) -> Dict[str, str]:
    """Load a simple KEY=VALUE env file."""

    values: Dict[str, str] = {}
    if not path.exists():
        raise FileNotFoundError(f"Brak pliku konfiguracyjnego: {path}")
    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        values[key.strip()] = value.strip()
    return values


def sync_sentry_overrides(env_path: Path) -> Dict[str, str]:
    """Persist Sentry DSN/environment metadata into runtime overrides."""

    env_values = load_env_file(env_path)
    sentry_block = {
        "dsn": env_values.get("SENTRY_DSN", ""),
        "environment": env_values.get("SENTRY_ENVIRONMENT", "production"),
        "release": env_values.get("SENTRY_RELEASE", "unknown"),
    }

    existing: Dict[str, object] = {}
    if RUNTIME_OVERRIDES_FILE.exists():
        existing = json.loads(RUNTIME_OVERRIDES_FILE.read_text(encoding="utf-8"))

    existing["sentry"] = sentry_block
    RUNTIME_OVERRIDES_FILE.write_text(
        json.dumps(existing, indent=2, ensure_ascii=False) + "\n", encoding="utf-8"
    )
    return sentry_block


def build_payload() -> Dict[str, object]:
    libraries, missing_any = check_libraries()
    software_backend = None
    if missing_any:
        software_backend = configure_software_backend()
    else:
        software_backend = {"status": "not_required"}

    payload = {
        "platform": platform.platform(),
        "python": platform.python_version(),
        "modules": check_modules(),
        "system_libraries": libraries,
        "software_backend": software_backend,
        "notes": (
            "Uruchom ten skrypt na maszynie docelowej. Jeśli zależności są brakujące,"
            " wykonaj sugerowane komendy instalacyjne przed wydaniem."
        ),
    }

    return payload


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--sync-sentry",
        action="store_true",
        help="Zapisz konfigurację Sentry z pliku production.env do runtime_overrides.json",
    )
    parser.add_argument(
        "--env-file",
        default=str(
            PRODUCTION_ENV_FILE
            if PRODUCTION_ENV_FILE.exists()
            else PRODUCTION_ENV_TEMPLATE
        ),
        help="Ścieżka do pliku .env zawierającego konfigurację produkcyjną",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help=(
            "Zachowano dla kompatybilności ze skryptami wydaniowymi. "
            "Wyjście skryptu zawsze jest w formacie JSON."
        ),
    )
    args = parser.parse_args()

    payload = build_payload()

    if args.sync_sentry:
        env_path = Path(args.env_file)
        sentry_block = sync_sentry_overrides(env_path)
        payload["sentry"] = {
            "status": "synced",
            "path": str(RUNTIME_OVERRIDES_FILE),
            "values": sentry_block,
        }
    else:
        payload["sentry"] = {"status": "skipped"}

    output = json.dumps(payload, indent=2, ensure_ascii=False)
    print(output)
    Path("runtime_dependency_report.json").write_text(output + "\n", encoding="utf-8")


if __name__ == "__main__":
    main()
